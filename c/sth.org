# -*- coding:utf-8 -*-
#+LANGUAGE:  zh
#+TITLE:     c cpp 拾遗
#+AUTHOR:    纪秀峰
#+EMAIL:     jixiuf@gmail.com
#+DATE:     2012-08-01 星期三
#+DESCRIPTION:c拾遗
#+KEYWORDS: @C
#+OPTIONS:   H:2 num:nil toc:t \n:t @:t ::t |:t ^:nil -:t f:t *:t <:t
#+OPTIONS:   TeX:t LaTeX:t skip:nil d:nil todo:t pri:nil
#+FILETAGS:@C
* make_mark
#+BEGIN_SRC c
比如MAKE_MASK(3 )会生成  二进制的 00000111
#define MAKE_MASK(n)  ((((int)1) << (n)) -1)
#+END_SRC
* c cpp  的一些判断
#+BEGIN_SRC c
if(flag)
if(!flag)
而非
if(0==flag)

判断指针非空用
if(p==NULL) // NULL 定义的 #include<cstdlib>  或c的stdlib.h
尽量少用:
if(p)
if(p==0)
#+END_SRC

* const 的作用
1. 定义常量
2. 在函数的返回值或参数中对其类型进行限制，防止函数内修改参数，一般多指指针类型
* c++的初始化
  #+BEGIN_SRC c++
       int i(1024);// 直接初始化
       int i=1024; //复制初始化

    #include<string>
    std:string str="asfdasd";
    std:string str("asfdasd");
  #+END_SRC
* c++ 的声明与定义，
  声明可以多次， 定义只能一次，声明不分配内存
  用extern关键来来声明
  #+BEGIN_SRC c++
    extern int i ;//声明i
    int i ;//声明 并定义,所以这是定义 ，不可以出现多次
    int i=2 ;//声明 并定义,并初始值
    因为声明 不分配内存 所以不可以初始化，一旦有初始化的行为，则认为是定义，即便使用了ertern 也认为是定义而非声明
    extern int i =3; // 声明 定义 并初始化， 这里的extern 几乎无意义.
   定义之后可以再次出现 单独声明的语句， 但是不能出现
  #+END_SRC
  #+BEGIN_SRC c++
    int main(int argc, char *argv[]){
      extern  string s;// 只是声明 ，编译会报错
      std::cout << s << std::endl;
    }
  #+END_SRC
  非const 变量默认extern ,要使const 变量可以在其他文件中使用，
  必须在本文件及其他文件中声明它为extern
  默认const 变量只在定义它的文件中有用的局部变量,
** 在头文件中不可以出现定义,只能有声明,因为会被多个源文件引用， 导致多处定义
   头文件里不能有定义有3个例外:
  1. 定义类
  2. 编译期就已经知道的const对象
  3. 内联函数
  这些实体可在多个源文件中出现 只要处处定义相同
  编译器需要知道这些来产生代码(为什么允许这3个例外)
  默认const 变量只在定义它的文件中有用的局部变量,这样规定后， const变量就允许
  出现在头文件里,但是必须用常量表达式出始化 否则必须像正常变量一样源文件里定义并
  初始化，在头文件里添加extern 声明，以使其被多个文件共享
  const int a = squt(2 ) ;就不是常量表达式
* c++ 引用
  引用不可以为null ,定义时必须初始化,
  初始化后，不可能绑定到其他对象了,所以一个引用只能绑定一个对象
  const 引用 是指向 const对象的 引用 both ref and object are const
  #+BEGIN_SRC c++
  int i =1;
  int &iRef=i;//正确
  int &iRef2; //错
  int &iref3=10;//错  10是常量

  const  int i3=10;
  const  int &i3ref=i3;//对
  int &i3ref2=i3;//错 必须 加 const

  const int &i4=111;//对 ，const引用可以指向常量
  #+END_SRC
* c++ 枚举 enum
  #+BEGIN_SRC c++
  enum Forms{shape=1,sphere,cylinder,polygon}
  枚举的值后一个比前一个加1,除非显示初始化
  shape=1 , sphere=2,cylinder=3,

  枚举的值可以重复
  enum Forms{shape=1,sphere,cylinder=2,polygon}
  则shape=1 sphere=2 cylinder=2 polygon=3
 定义成枚举后， 枚举跟int是不同类型
 如
Froms f1=shape; //ok
Froms f2=2 ; // error


  #+END_SRC
* string 相关
**  string.size() 返回string::size_type类型,而非int
  #+BEGIN_SRC c++
    string::size_type len=  s.size();//ok
    int len=  s.size();//error, 但是我试了 编译运行都 可过， 但是不推荐
  #+END_SRC
** 取string第n个字符用[]下标操作即可,也可对其赋值,只能对已经存在的元素赋值，不能添加
   []中的数是一个size_type类型,从0 始计
  #+BEGIN_SRC c++
    string str("hello");
    char c=str [1];
    std::cout << c << std::endl;
    str[1]='E';
    std::cout << str << std::endl;  // "hEllo"
  #+END_SRC
   #+BEGIN_SRC c++
     遍历
     for (string::size_type  i= 0; i < str.size(); i++){
       std::cout << str[i] << std::endl;
      }
   #+END_SRC
** cctype 头文件里一些函数如isupper tolower isspace
#+BEGIN_SRC c++
  #include <cctype>
  // isdigit(int)
  // islower(int)
  // isupper
  // isalnum
  // isspace 这些函数也是在std::下的
  char c='d';
  std::cout << isupper(c) << std::endl;

#+END_SRC
* vector 容器
  是同一种类型的对象的集合
  vector是类模版，不是数据类型
  vector<int> vector<string>则是数据类型
#+BEGIN_SRC c++
  vector<string> v1;
  string s1("aaa");
  string s2("bbb");

  v1.push_back(s1);
  v1.push_back(s2);
  vector<string> v2(v1);

  s1="ccc";//对s1的改变 变不会影响v1 v2中的元素

  // size_type类型的写法,不可以写成vector::size_type
  for (vector<string>::size_type i = 0; i<v1.size(); i++) {
    std::cout << v1.at(i) << std::endl;
   } // 打印后的是"aaa" "bbb",
  std::cout << "" << std::endl;

  for (vector<string>::size_type i = 0; i<v2.size(); i++) {
    std::cout << v2.at(i) << std::endl;
   }// 打印后的是"aaa" "bbb",
#+END_SRC
** vector [] 下标操作同 string ,可get 可set,只能针对存在的元素,但不能add
** 使用iterator
   #+BEGIN_SRC c++
     # vector1.begin()指向首元素，
     #vector1.end()指向尾元素的下一个位置
     iterator的解引用操作(*it)，取得指向元素的对象 如元素类型是string ,则返回的是string对象
     for (vector<string>::iterator it =  v1.begin();it!= v1.end() ; it++){
       std::cout << *it << std::endl;
       *it= *it+"hello";  //可以改变元素的值
     }
   #+END_SRC
** 使用const_iterator
   与iterator一样， 只是不能对iterator指向的元素进行赋值操作.
   其指向的元素是只读的，并不是 const_iterator只读
   意思是不能改变它指向元素的值， 但能改变他指向什么元素
   所以 const vector<string>:iterator it;
        vector<string>:const_iterator it;
        并不相同
** vector的iterator可以进行简单的算术运算操作，
   不是所有的容器类型都支持
   iter+n
   iter-n
   iter1-iter2
   // 返回两元素间的位置差,返回的类型是vector<string>:difference_type
   //可正可负
** 任何改变vector长度的操作，都会使已存在的iterator 失效,
   如push_back()之后，   原来iterator指向的值就不可信了
* bitset
   bitset 是模版， 不同的是区别只在长度 ，不在类型
  #+BEGIN_SRC c++
    #include<bitset>
    using std::bitset;
    bitset<32> bs; //32 bits all 0
    bitset<16> bs2(0xffff);// 用0xffff的低16位填充
    bs[0]  指的是低位第一位
    bitset<16> bs2("11110001");

   // bitset 提供 了 set all() any() ,count() test(pos)
   //  flip()  flip(pos) 按位取反
   // to_string to_ulong()
   //  std::cout << bs << std::endl; //可以直接 入 流
   // count() 返回有多少位是1，类型是size_t,在 #include<cstddef>中定义
  #+END_SRC
* 数组
  数组的维数 只能用 包含整形字面值常量、枚举常量 或者用常量表达式初始化的整形
  const对象 ,非const变量， 以及到运行时才知道其值的const变量都不能用来定义其维数
  #+BEGIN_SRC c++
    const int i=10;
    int j=10;
    int arr[i+1];                   // 合法的 常量表达式(i是const变量， 编译其就知道其大小)
    int arr2[j];                   // 不合法的 (j不是const变量， 编译其不知道其大小)
  #+END_SRC
** 初始化
#+BEGIN_SRC c++
  //数组初始化
  int array[3] = {1,2,3};
  int array[] = {1,2,3};//不指定数据长度也可，此时
  char array[] = "c";//等同于 char array[]= {'c','\0'}
  // 可以用sizeof(array) 取数组的长度(数组的长度编译期就确定了，所以sizeof可以做到, c语言里也一样)
  // 但是 数组作为参数传递时会自动转化成char* 指针， 它是没法取到数组的长度的
#+END_SRC

***  在函数体外定义的内置类型的数组，其元素初始化为0
***  在函数体内定义的内置类型的数组，其元素未初始化，
*** 不论数组在哪定义，若元素类型为类，则自动调用其默认构造函数初始化，若无默认构造函数，则必须显示初始化
* 指针
** 指针的定义 风格
  #+BEGIN_SRC c++
   char *p1 ,*p2; //p1 p2 都是指针

  //p1 是指针 ，p2是char ,//跟 char *p1 p2;写法一样
  // 建议使用 char *p1 ,而非 char* p1;
   char* p1 p2 ;
  #+END_SRC
** 指针的初始化
#+BEGIN_SRC c++
  //指针不可以用int类型的变量来赋值,
   //但可以用值为0 的const 变量来初始化
  int a =0;
  const b=0;
  int *p =a;//错误
  int *p2=b;// ok,
  int *p2=0;// ok,
  int *p2=NULL;// ok, #include<cstdlib>
#+END_SRC
** 指针类型要匹配
   #+BEGIN_SRC c++
   double d =10;
   double *pd=&d;
   int *pi =pd;//error
   #+END_SRC
** 指针与引用的区别
   1. 引用必须指向某个对象，不可以为null, 必须进行初始化
   2. 赋值行为的差异，对指针进行赋值，是让指针指向另一个对象
      而对引用进行赋值，则是改变当前引用所指对象的值(引用就是对象)
** 指针的运算
   指针的类型不能乱用，所以一个指针是什么类型的是知道的 ，
   对指针加一个数， 实际就是将指针往后移动这种类型的一个单位
   比如
   #+BEGIN_SRC c++
     int i=1;
     int *p =&i;
     p++; //往后移动一个int单位,指向下一个int
    *(p+4) ;//可以这样取p往后挪4个 int后所指对象的值
   #+END_SRC
** 指向const对象的指针 和const 指针(本身的值不可变)
*** 指向const对象的指针
   #+BEGIN_SRC c++
     const double d=1;
     const double *p=&d;//ok, 指向const 对象的指针 ,p 并不是const的
     double *p2 = &d;//error ,普通的指针 不可以指向const对象
     void *p3 = &d ;//错
     const void *p4=&d;//ok

     允许 把非const对象的地址赋值给 指向const对象的指针
      double d2=2;

     // 自以为指向const对象的指针
      const double *p5 =&d2;     //ok, 但是不能通过*p5来改变 d2的值,虽然可以通过其他方法改d2的值
   #+END_SRC
*** const 指针(本身的值不可变),即定义时必须初始化
    #+BEGIN_SRC c++
     int i=1;
     int *const p = &i;// p 只能指向i , 不可以指向其他值了
    #+END_SRC
*** typedef 与const易引起歧义
#+BEGIN_SRC c++
 typedef string *pstring;
 const pstring ctr;
 并不能简单的将 上述两句像宏一样 扩展成 const  *pstring ctr; ,这则说明ctr是指向const对象的指针
 而实际 ctr 是const 指针 ,即， 不可以将ctr再指向其他对象 ，但可以改变当前所指对象的值

可以这样理解， typedef string *pstring ; 说明 这种类型的指向string的指针， 并没有const限定,
const pstring ctr; 这里const只是限定ctr这个变量，  而非pstring这种类型， 这种类型在typedef时就已经确定了
并不会因为在它前面加一个const 就改变
#+END_SRC
* 动态数组
 普通数组长度在编译期就需要确定下来，动态数组长度可以在运行期确定
 #+BEGIN_SRC c++
  int *p = new int[10];//返回指向第一个元素的指针

   动态数据允许长度为0
 int *p = new int[0];//ok, 返回不是空， 但是不能进行解引用操作， 似类于vector.end()的返回值
  int i[0]; //error

  delete[] p; //释放
 #+END_SRC
* -> 操作符
  #+BEGIN_SRC c++
  Item item;
  Item *p=&item;
  item.sth().
  // 下面这两个操作同义
  (*p).sth().
   p->sth().
  #+END_SRC
* sizeof 操作符 的结果是 编译时常量
  #+BEGIN_SRC c++
    int array[3]={1,2,3};
    sizeof(array); //12  3*sizeof(int)
  #+END_SRC

#+BEGIN_SRC c++
  char *c=(char*) malloc(sizeof(char)*3);
  strcpy(c, "ab");
  std::cout << sizeof(c) << std::endl; // 4 返回指针的大小
  std::cout << sizeof(*c) << std::endl; //1 返回指针所指对象的大小
  // 上面两个都没有返回"ab"长度相关的内容
#+END_SRC
* new delete
#+BEGIN_SRC c++
 string *str= new string; //初始化为空串
 int *i = new int;   //内建类型 则未初始化

*
 int *j  = new int(); // 初始化为0
#+END_SRC
* 强制类型转换( static_cast const_cast, dynamic_cast, reinterpret_cast)
** static_cast 默认所有的隐式类型转换，都可以通过static_cast显示实现
   #+BEGIN_SRC c++
     double d =1;
     int i =2;
     i *= static_cast<int>(d) ;// 将d 强制转化成int ,然后与 int i相乘

     void *p = &d;
     double *pd= static_const<double*> (p);
   #+END_SRC
** const_cast 去掉var的const 属性
   #+BEGIN_SRC c++
     void test(char* c){}
     int main(){
       const char* c;
       test(c);// error
       test(const_cast<char*>(c)); //ok
     }
   #+END_SRC
** reinterpret_cast
   #+BEGIN_SRC c++
      int i =1;
     int *ip=&i;
     //  转化之后， pc 依然是int* 类型的指针
     char *pc = reinterpret_cast<char*>(ip);
     string str(pc);////导致运行时error, 但是编译时不会出警告
    //用int 来初始化string
   #+END_SRC
#+BEGIN_SRC c++
  char* pc=(char*)ip;//  c++ 似乎不建议使用 这种c里使用的强转
  //效果与使用 reinterpret_cast一样
  //这种强转 具有 static_cast const_cast  reinterpret_cast 相同的功能,更笼统
#+END_SRC
* switch
  执行到某个case后，如果不加break，会继续执行余下的case里的代码
  所以 在case里定义变量，可能导致重复定义同一个变量，或者因为没有执行某个case里
  的定义 ，导致 后面的case使用未定义 的变量,
  所以switch里除了最后一个case 或default可以定义变量外， 其他case语句里不可以定
  义变量, 如果一定要在case里定义变量可以用块语句(即大括号),在大括号里定义的变量
  只在此块中有效

  #+BEGIN_SRC c++
    int i=1;
    switch (i) {
    case 1:
      int j =0; // 这句出错，
      break;
    case 2:
      int j =0;
      break;
    }
  #+END_SRC
* 内联函数
** 内联函数应该在头文件中定义(对编译器必须是可见的)
* 成员函数
** 成员函数可在类外或类内定义，在类内定义 ，编译器隐式的将其转成内联函数
** 成员函数的隐含形参this 是一个指针(不是引用),指向调用此函数的对象的地址
   #+BEGIN_SRC c++
     class Test
     {
     public:
       Test(int parmI){
         i=parmI;
       }
       bool test(int j) const{// const 是对this 对象的限制,意思是说此函数内不可以改变this对象的属性
         // this->i=3; // 这种编译出错，尝试对const this对象进行修改

         //  这两种方式是一样的
         // return i==j;
         return this->i==j;
       }
     private:
       int i;
     };
   #+END_SRC
* 构造函数
** 必须在类中声明， 可在类内或类外定义
** 构造函数的初始化列表(在参数列表后，函数体前的代码)
#+BEGIN_SRC c++
  class Test
  {
  public:
    Test(int parmI):i(parmI){
    }
  private:
    int i;
  };

#+END_SRC
** 默认构造函数不能自动初始化 内置类型 的成员,必须自定义构造函数初始化这些成员,对于类类型的成员默认用他们默认构造函数来初始化
* 函数重载(同一个类中 ，函数名相同参数不同)
** 参数不同的含义，使用typedef定义一个别名后，认为使用别名跟使用本名是同一种类型
** 参数的const 与否，与重载
*** 对于值传递的参数,操作的只是副本,const与否并不影响副本,
值传递参数 仅const 的区别,认为是同一个函数,不能根据是否有const来区分两个函数
#+BEGIN_SRC c++
   以下两种重载是  不 允许的
  string getj(const int pi){
  }
  string getj(int pi){
  }

  string getj(const Test pi){
  }
  string getj(Test pi){
  }
#+END_SRC
*** 对于引用形参和指针形参 可以根据 是否const 来区分两个函数
    #+BEGIN_SRC c++
     // 以下两种重载是允许的
      string getj(const int *pi){
        return str;
      }
      string getj(int *pi){
        return str;
      }

      string getj(const int &pi){
        return str;
      }
      string getj(int &pi){
        return str;
      }
    #+END_SRC
** 不能仅仅根据返回值类型不同来区别两个函数
* 函数指针
  #+BEGIN_SRC c++
   typedef bool (*compFun) (const string &,const string);
    // 以下两种方式 效果相同
    compFun comF1= lengComp;
    compFun comF2= &lengComp;

   //调用 的时候 以下效果也相同
   compF1(str1,str2);
   (*compF1)(str1,str2);
  #+END_SRC
* IO
** 类的关系
    fstream sstring中定义的类型都是从iostream中定义的类型继承而来
|----------+------------------------------------------+--------|
| 头文件   | 头文件中的类                             | 类型   |
|----------+------------------------------------------+--------|
| iostream | istream,ostream,iostream                 |        |
| fstream  | ifstream ofstream fstream                | 文件   |
| sstream  | istringstream,ostringstream,stringstream | string |
|----------+------------------------------------------+--------|
#+BEGIN_SRC ditaa :file ../img/cpp-io-class.png :cmdline  -r -S -E
                       +---------+                                    +-------+
                       |         | ^                                ^ |       | ^
                       |         |  \                              /  |       |  \
                       |ostream  |   \                            /   |istream|   \
                      ^+-+-------+    \                          /    +---+---+    \
                     /   ^             \                        /         ^         \
                    /    |              \                      /          |          \
                   /     |                +-----------------+             |           \
                  /      |                |                 |             |            \
                 /       |                |  iostream       |             |             \
                /        |                |                 |             |              \   +-----------+
               /         |                +-----------------+             |               \  |cBLU       |
  +--------------+       |                ^                 ^             |                \ |ifstream   |
  |cBLU ofstream |       |                |                 |             |                  |           |
  |              |       |                |                 |             |                  |           |
  |              |       |                |                 |             |                  +-----------+
  +--------------+       |                |                 |             |
                         |                |                 |             |
                         |                |                 |             |
                         |       +--------+----+       +----+------+      |
                         |       |cPNK         |       |cBLU       |      |
                         |       |stringstream |       |fstream    |      |
                         |       |             |       |           |      |
                         |       +-------------+       +-----------+      |
                +-----------------+                                       |
                |cPNK             |                                +------+------+
                |ostringstream    |                                |cPNK         |
                |                 |                                |istringstream|
                |                 |                                |             |
                +-----------------+                                +-------------+
#+END_SRC

** io 与宽字符
   以上类名前加一个w ,则支持读写wchar_t类型的字符，如 wostream wistream

** IO 对象 不可赋值或复制
** 条件状态
   | eof()                   | 判断是否eof                |
   | good()                  | 流处于有效状态，则true     |
   | fail()                  | 失败的IO操作               |
   | bad()                   | 是否被破坏，strm::badbit位 |
   | clear()                 | 重置所有状态为有效态       |
   | clear(flag)             | 重置某状态为有效态         |
   | setstate(strm::iostate) |                            |
   | rdstate()               | 返回strm::iostate          |
#+BEGIN_SRC c++
  int i;
  cin>>i;
  if(cin){// 这里是判断 cin是处于有效状态，cin跟据当前条件状态 自动转换 成bool
  }
#+END_SRC
#+BEGIN_SRC c++
  #include <iostream>
  #include <string>
  #include <stdio.h>
  #include <stdlib.h>
  using std::cin;
  using std::cout;
  using std::cerr;
  using std::endl;
  using std::string;
  using std::istream;
  int read_int(istream &in){
    int i =0;
    while(in>>i , !in.eof()){// 读取一个int ,然后判断是否读到结尾
      if(in.bad()){
        exit(1);
      }else if (in.fail()){
        cerr<<"bad data,not int ,try again " <<std::endl;
        in.clear(istream::failbit); // reset failbit
        std::cerr<< "failbit flag after in.clear(istream::failbit) "<< in.fail() << std::endl;
        in.clear();
        std::cerr << "failbit flag after in.clear() "<< in.fail() << std::endl;
        cin.ignore();// 忽略掉上次读取失败的字符，以便继续读下一个
        continue;
      }else{//成功读取一个int后退出循环
        break;
      }
    }
    return i;
  }
  main(int argc, char *argv[]){
    int i =read_int(cin);
    std::cout << i << std::endl;
  }
#+END_SRC
** File
#+BEGIN_SRC c++
  //一行行读取一个文件， 写到另一个文件
  main(int argc, char *argv[]){
    ifstream fin("c.cpp");
    ofstream fout("c.cpp2");
    string buf;
    if (fin ){
      while(std::getline(fin, buf)){
        fout<< buf <<std::endl ;
      }
    }
    fout.close();
    fin.close();
  }
#+END_SRC
** open close
   #+BEGIN_SRC c++
    ifstream fin;
    fin.open("filename");
    fin.close();
   #+END_SRC
