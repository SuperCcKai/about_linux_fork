# -*- coding:utf-8 -*-
#+LANGUAGE:  zh
#+TITLE:     c cpp 拾遗
#+AUTHOR:    纪秀峰
#+EMAIL:     jixiuf@gmail.com
#+DATE:     2012-08-01 星期三
#+DESCRIPTION:c拾遗
#+KEYWORDS: @C
#+OPTIONS:   H:2 num:nil toc:t \n:t @:t ::t |:t ^:nil -:t f:t *:t <:t
#+OPTIONS:   TeX:t LaTeX:t skip:nil d:nil todo:t pri:nil
#+FILETAGS:@C
* make_mark
#+BEGIN_SRC c
比如MAKE_MASK(3 )会生成  二进制的 00000111
#define MAKE_MASK(n)  ((((int)1) << (n)) -1)
#+END_SRC
* c cpp  的一些判断
#+BEGIN_SRC c
if(flag)
if(!flag)
而非
if(0==flag)

判断指针非空用
if(p==NULL)
尽量少用:
if(p)
if(p==0)
#+END_SRC

* const 的作用
1. 定义常量
2. 在函数的返回值或参数中对其类型进行限制，防止函数内修改参数，一般多指指针类型
* c++的初始化
  #+BEGIN_SRC c++
       int i(1024);// 直接初始化
       int i=1024; //复制初始化

    #include<string>
    std:string str="asfdasd";
    std:string str("asfdasd");
  #+END_SRC
* c++ 的声明与定义，
  声明可以多次， 定义只能一次，声明不分配内存
  用extern关键来来声明
  #+BEGIN_SRC c++
    extern int i ;//声明i
    int i ;//声明 并定义,所以这是定义 ，不可以出现多次
    int i=2 ;//声明 并定义,并初始值
    因为声明 不分配内存 所以不可以初始化，一旦有初始化的行为，则认为是定义，即便使用了ertern 也认为是定义而非声明
    extern int i =3; // 声明 定义 并初始化， 这里的extern 几乎无意义.
   定义之后可以再次出现 单独声明的语句， 但是不能出现
  #+END_SRC
  #+BEGIN_SRC c++
    int main(int argc, char *argv[]){
      extern  string s;// 只是声明 ，编译会报错
      std::cout << s << std::endl;
    }
  #+END_SRC
  非const 变量默认extern ,要使const 变量可以在其他文件中使用，
  必须在本文件及其他文件中声明它为extern
  默认const 变量只在定义它的文件中有用的局部变量,
** 在头文件中不可以出现定义,只能有声明,因为会被多个源文件引用， 导致多处定义
   头文件里不能有定义有3个例外:
  1. 定义类
  2. 编译期就已经知道的const对象
  3. 内联函数
  这些实体可在多个源文件中出现 只要处处定义相同
  编译器需要知道这些来产生代码(为什么允许这3个例外)
  默认const 变量只在定义它的文件中有用的局部变量,这样规定后， const变量就允许
  出现在头文件里,但是必须用常量表达式出始化 否则必须像正常变量一样源文件里定义并
  初始化，在头文件里添加extern 声明，以使其被多个文件共享
  const int a = squt(2 ) ;就不是常量表达式
* c++ 引用
  引用不可以为null ,定义时必须初始化,
  初始化后，不可能绑定到其他对象了,所以一个引用只能绑定一个对象
  const 引用 是指向 const对象的 引用 both ref and object are const
  #+BEGIN_SRC c++
  int i =1;
  int &iRef=i;//正确
  int &iRef2; //错
  int &iref3=10;//错  10是常量

  const  int i3=10;
  const  int &i3ref=i3;//对
  int &i3ref2=i3;//错 必须 加 const

  const int &i4=111;//对 ，const引用可以指向常量
  #+END_SRC
* c++ 枚举 enum
  #+BEGIN_SRC c++
  enum Forms{shape=1,sphere,cylinder,polygon}
  枚举的值后一个比前一个加1,除非显示初始化
  shape=1 , sphere=2,cylinder=3,

  枚举的值可以重复
  enum Forms{shape=1,sphere,cylinder=2,polygon}
  则shape=1 sphere=2 cylinder=2 polygon=3
 定义成枚举后， 枚举跟int是不同类型
 如
Froms f1=shape; //ok
Froms f2=2 ; // error


  #+END_SRC
* string 相关
**  string.size() 返回string::size_type类型,而非int
  #+BEGIN_SRC c++
    string::size_type len=  s.size();//ok
    int len=  s.size();//error, 但是我试了 编译运行都 可过， 但是不推荐
  #+END_SRC
** 取string第n个字符用[]下标操作即可,也可对其赋值,只能对已经存在的元素赋值，不能添加
   []中的数是一个size_type类型,从0 始计
  #+BEGIN_SRC c++
    string str("hello");
    char c=str [1];
    std::cout << c << std::endl;
    str[1]='E';
    std::cout << str << std::endl;  // "hEllo"
  #+END_SRC
   #+BEGIN_SRC c++
     遍历
     for (string::size_type  i= 0; i < str.size(); i++){
       std::cout << str[i] << std::endl;
      }
   #+END_SRC
** cctype 头文件里一些函数如isupper tolower isspace
#+BEGIN_SRC c++
  #include <cctype>
  // isdigit(int)
  // islower(int)
  // isupper
  // isalnum
  // isspace 这些函数也是在std::下的
  char c='d';
  std::cout << isupper(c) << std::endl;

#+END_SRC
* vector 容器
  是同一种类型的对象的集合
  vector是类模版，不是数据类型
  vector<int> vector<string>则是数据类型
#+BEGIN_SRC c++
  vector<string> v1;
  string s1("aaa");
  string s2("bbb");

  v1.push_back(s1);
  v1.push_back(s2);
  vector<string> v2(v1);

  s1="ccc";//对s1的改变 变不会影响v1 v2中的元素

  // size_type类型的写法,不可以写成vector::size_type
  for (vector<string>::size_type i = 0; i<v1.size(); i++) {
    std::cout << v1.at(i) << std::endl;
   } // 打印后的是"aaa" "bbb",
  std::cout << "" << std::endl;

  for (vector<string>::size_type i = 0; i<v2.size(); i++) {
    std::cout << v2.at(i) << std::endl;
   }// 打印后的是"aaa" "bbb",
#+END_SRC
** vector [] 下标操作同 string ,可get 可set,只能针对存在的元素,但不能add
** 使用iterator
   #+BEGIN_SRC c++
     # vector1.begin()指向首元素，
     #vector1.end()指向尾元素的下一个位置
     iterator的解引用操作(*it)，取得指向元素的对象 如元素类型是string ,则返回的是string对象
     for (vector<string>::iterator it =  v1.begin();it!= v1.end() ; it++){
       std::cout << *it << std::endl;
       *it= *it+"hello";  //可以改变元素的值
     }
   #+END_SRC
** 使用const_iterator
   与iterator一样， 只是不能对iterator指向的元素进行赋值操作.
   其指向的元素是只读的，并不是 const_iterator只读
   意思是不能改变它指向元素的值， 但能改变他指向什么元素
   所以 const vector<string>:iterator it;
        vector<string>:const_iterator it;
        并不相同
** vector的iterator可以进行简单的算术运算操作，
   不是所有的容器类型都支持
   iter+n
   iter-n
   iter1-iter2
   // 返回两元素间的位置差,返回的类型是vector<string>:difference_type
   //可正可负
** 任何改变vector长度的操作，都会使已存在的iterator 失效,
   如push_back()之后，   原来iterator指向的值就不可信了
* bitset
   bitset 是模版， 不同的是区别只在长度 ，不在类型
  #+BEGIN_SRC c++
    #include<bitset>
    using std::bitset;
    bitset<32> bs; //32 bits all 0
    bitset<16> bs2(0xffff);// 用0xffff的低16位填充
    bs[0]  指的是低位第一位
    bitset<16> bs2("11110001");

   // bitset 提供 了 set all() any() ,count() test(pos)
   //  flip()  flip(pos) 按位取反
   // to_string to_ulong()
   //  std::cout << bs << std::endl; //可以直接 入 流
   // count() 返回有多少位是1，类型是size_t,在 #include<cstddef>中定义
  #+END_SRC
* 数组
  数组的维数 只能用 包含整形字面值常量、枚举常量 或者用常量表达式初始化的整形
  const对象 ,非const变量， 以及到运行时才知道其值的const变量都不能用来定义其维数
  #+BEGIN_SRC c++
    const int i=10;
    int j=10;
    int arr[i+1];                   // 合法的 常量表达式(i是const变量， 编译其就知道其大小)
    int arr2[j];                   // 不合法的 (j不是const变量， 编译其不知道其大小)
  #+END_SRC
** 初始化
#+BEGIN_SRC c++
  //数组初始化
  int array[3] = {1,2,3};
  int array[] = {1,2,3};//不指定数据长度也可，此时
  char array[] = "c";//等同于 char array[]= {'c','\0'}
  // 可以用sizeof(array) 取数组的长度(数组的长度编译期就确定了，所以sizeof可以做到, c语言里也一样)
  // 但是 数组作为参数传递时会自动转化成char* 指针， 它是没法取到数组的长度的
#+END_SRC

***  在函数体外定义的内置类型的数组，其元素初始化为0
***  在函数体内定义的内置类型的数组，其元素未初始化，
*** 不论数组在哪定义，若元素类型为类，则自动调用其默认构造函数初始化，若无默认构造函数，则必须显示初始化
* 指针
** 指针的定义 风格
  #+BEGIN_SRC c++
   char *p1 ,*p2; //p1 p2 都是指针

  //p1 是指针 ，p2是char ,//跟 char *p1 p2;写法一样
  // 建议使用 char *p1 ,而非 char* p1;
   char* p1 p2 ;
  #+END_SRC
** 指针的初始化
#+BEGIN_SRC c++
  //指针不可以用int类型的变量来赋值,
   //但可以用值为0 的const 变量来初始化
  int a =0;
  const b=0;
  int *p =a;//错误
  int *p2=b;// ok,
  int *p2=0;// ok,
  int *p2=NULL;// ok, #include<cstdlib>
#+END_SRC
** 指针类型要匹配
   #+BEGIN_SRC c++
   double d =10;
   double *pd=&d;
   int *pi =pd;//error
   #+END_SRC
** 指针与引用的区别
   1. 引用必须指向某个对象，不可以为null, 必须进行初始化
   2. 赋值行为的差异，对指针进行赋值，是让指针指向另一个对象
      而对引用进行赋值，则是改变当前引用所指对象的值(引用就是对象)
** 指针的运算
   指针的类型不能乱用，所以一个指针是什么类型的是知道的 ，
   对指针加一个数， 实际就是将指针往后移动这种类型的一个单位
   比如
   #+BEGIN_SRC c++
     int i=1;
     int *p =&i;
     p++; //往后移动一个int单位,指向下一个int
    *(p+4) ;//可以这样取p往后挪4个 int后所指对象的值
   #+END_SRC
** 指向const对象的指针 和const 指针(本身的值不可变)
*** 指向const对象的指针
   #+BEGIN_SRC c++
     const double d=1;
     const double *p=&d;//ok, 指向const 对象的指针 ,p 并不是const的
     double *p2 = &d;//error ,普通的指针 不可以指向const对象
     void *p3 = &d ;//错
     const void *p4=&d;//ok

     允许 把非const对象的地址赋值给 指向const对象的指针
      double d2=2;

     // 自以为指向const对象的指针
      const double *p5 =&d2;     //ok, 但是不能通过*p5来改变 d2的值,虽然可以通过其他方法改d2的值
   #+END_SRC
*** const 指针(本身的值不可变),即定义时必须初始化
    #+BEGIN_SRC c++
     int i=1;
     int *const p = &i;// p 只能指向i , 不可以指向其他值了
    #+END_SRC
*** typedef 与const易引起歧义
#+BEGIN_SRC c++
 typedef string *pstring;
 const pstring ctr;
 并不能简单的将 上述两句像宏一样 扩展成 const  *pstring ctr; ,这则说明ctr是指向const对象的指针
 而实际 ctr 是const 指针 ,即， 不可以将ctr再指向其他对象 ，但可以改变当前所指对象的值

可以这样理解， typedef string *pstring ; 说明 这种类型的指向string的指针， 并没有const限定,
const pstring ctr; 这里const只是限定ctr这个变量，  而非pstring这种类型， 这种类型在typedef时就已经确定了
并不会因为在它前面加一个const 就改变
#+END_SRC
* 动态数组
 普通数组长度在编译期就需要确定下来，动态数组长度可以在运行期确定
 #+BEGIN_SRC c++
  int *p = new int[10];//返回指向第一个元素的指针

   动态数据允许长度为0
 int *p = new int[0];//ok, 返回不是空， 但是不能进行解引用操作， 似类于vector.end()的返回值
  int i[0]; //error

  delete[] p; //释放
 #+END_SRC
