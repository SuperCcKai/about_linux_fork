<!DOCTYPE html>
<html lang="zh">
  <head>
    <title>go net包里的异步IO实现原理分析 - 拾遗笔记</title>
    <meta charset="utf-8" />
    <meta name="author" content="纪秀峰" />
    <meta name="description" content="go IO模型分析(epoll为例)" />
    <meta name="keywords" content="Golang IO epoll" />
    <link rel="stylesheet" href="/media/css/main.css" type="text/css">
    <!-- <link rel="stylesheet" href="/media/css/prettify.css" type="text/css"> -->
  </head>
  <body class="container">
<script async src="http://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- ji -->
<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-6633117582073327"
     data-ad-slot="1629980291"
     data-ad-format="link"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

    
    <div>
      <header class="masthead">
        <h1 class="masthead-title"><a href="/">拾遗笔记</a></h1>
        <p></p>
        <ul>
          <li><a href="/blog/">Blog</a></li>
          <li><a href="/tags/">Tags</a></li>
          <li><a href="/tags/">Tags</a></li>
          <li><a href="/about/">About</a></li>
          <li><a href="http://github.com/jixiuf">GitHub</a></li>
          <li><a href="/rss.xml">RSS</a></li>
        </ul>
        <form method="get" id="searchform" action="http://www.google.com/search">
          <input type="text" class="field" name="q" id="s" placeholder="Search">
          <input type="hidden" name="as_sitesearch" value="jixiuf.github.io">
        </form>
      </header>
    </div>

<div>
<div class="post">
<h1>go net包里的异步IO实现原理分析</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">epoll_create 的跟踪</a>
<ul>
<li><a href="#sec-1-1">流程之 设置IO非阻塞 syscall.SetNonblock(s, true)设置NonBlock 为true,</a></li>
<li><a href="#sec-1-2">epoll_create的流程 即epoll的初始化</a></li>
<li><a href="#sec-1-3">runtime_pollServerInit跟踪 这个过程会跟踪到epollcreate的调用</a></li>
</ul>
</li>
<li><a href="#sec-2">epoll_ctrl的跟踪</a></li>
<li><a href="#sec-3">epoll_wait 与golang 的异步IO</a></li>
</ul>
</div>
</div>
<p>
以DialTCP为例 分析初始化 epoll_create的流程分析过程中只保留关键代码<br  />
</p>
<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">epoll_create 的跟踪</h2>
<div class="outline-text-2" id="text-1">
</div><div id="outline-container-sec-1-1" class="outline-3">
<h3 id="sec-1-1">流程之 设置IO非阻塞 syscall.SetNonblock(s, true)设置NonBlock 为true,</h3>
<div class="outline-text-3" id="text-1-1">
<p>
DialTCP()-&gt;dialTCP()-&gt;internetSocket()-&gt;socket()<br  />
在socket()函数内首先会走到这个分支 sysSocket()-&gt;syscall.SetNonblock(s, true); 这里设置NonBlock 为true,即IO是非阻塞的<br  />
</p>

<ol class="org-ol">
<li>net/tcpsock.go/DialTCP<br  />
<div class="org-src-container">

<pre class="src src-go">func DialTCP(net string, laddr, raddr *TCPAddr) (*TCPConn, error) {
    c, err := dialTCP(context.Background(), net, laddr, raddr)
}
</pre>
</div>
</li>
<li>net/tcpsockopt_posix.go<br  />
<div class="org-src-container">

<pre class="src src-go">       func dialTCP(ctx context.Context, net string, laddr, raddr *TCPAddr) (*TCPConn, error) {
	   if testHookDialTCP != nil {
	       return testHookDialTCP(ctx, net, laddr, raddr)
	   }
	   return doDialTCP(ctx, net, laddr, raddr)
       }

       func doDialTCP(ctx context.Context, net string, laddr, raddr *TCPAddr) (*TCPConn, error) {
	   fd, err := internetSocket(ctx, net, laddr, raddr, syscall.SOCK_STREAM, 0, "dial")

	   return newTCPConn(fd), nil
       }
func internetSocket(ctx context.Context, net string, laddr, raddr sockaddr, sotype, proto int, mode string) (fd *netFD, err error) {
    family, ipv6only := favoriteAddrFamily(net, laddr, raddr, mode)
    return socket(ctx, net, family, sotype, proto, ipv6only, laddr, raddr)
}
</pre>
</div>
</li>
<li>net/sock_posix.go<br  />
<div class="org-src-container">

<pre class="src src-go">// socket returns a network file descriptor that is ready for
// asynchronous I/O using the network poller.
func socket(ctx context.Context, net string, family, sotype, proto int, ipv6only bool, laddr, raddr sockaddr) (fd *netFD, err error) {
    s, err := sysSocket(family, sotype, proto)  // 里面设置NonBlock 为true,即IO是非阻塞的
    if err != nil {
	return nil, err
    }
    //重要的一行,这里创建了 netFD结构体，
    if fd, err = newFD(s, family, sotype, net); err != nil {
	closeFunc(s)
	return nil, err
    }
     if err := fd.dial(ctx, laddr, raddr); err != nil { //这里call dial 函数
	 fd.Close()
	 return nil, err
     }


    return fd, nil
}
</pre>
</div>
</li>

<li>net/sock_cloexec.go<br  />
<div class="org-src-container">

<pre class="src src-go">func sysSocket(family, sotype, proto int) (int, error) {
    if err = syscall.SetNonblock(s, true); err != nil { //这里设置NonBlock 为true,即IO是非阻塞的
	closeFunc(s)
	return -1, os.NewSyscallError("setnonblock", err)
    }
}
</pre>
</div>
</li>
</ol>
</div>
</div>

<div id="outline-container-sec-1-2" class="outline-3">
<h3 id="sec-1-2">epoll_create的流程 即epoll的初始化</h3>
<div class="outline-text-3" id="text-1-2">
<p>
接着上面的socket()函数看<br  />
然后socket()内的流程 -&gt; fd.dial()-&gt;fd.connect()-&gt;fd.init()<br  />
会看到 流程会走到fd.init()的调用，这里的fd 是一个netFD结构<br  />
</p>

<ol class="org-ol">
<li>net/sock_posix.go<br  />
<div class="org-src-container">

<pre class="src src-go">// socket returns a network file descriptor that is ready for
// asynchronous I/O using the network poller.
func socket(ctx context.Context, net string, family, sotype, proto int, ipv6only bool, laddr, raddr sockaddr) (fd *netFD, err error) {
    s, err := sysSocket(family, sotype, proto)  // 里面设置NonBlock 为true,即IO是非阻塞的
    if err != nil {
	return nil, err
    }
	if err := fd.dial(ctx, laddr, raddr); err != nil { //这里call dial 函数
	    fd.Close()
	    return nil, err
	}


    return fd, nil
}

func (fd *netFD) dial(ctx context.Context, laddr, raddr sockaddr) error {
    //这个函数 无论哪个分支 最终都会走到 fd.init()  下面有注释
    if raddr != nil {
	if rsa, err = raddr.sockaddr(fd.family); err != nil {
	    return err
	}
	if err := fd.connect(ctx, lsa, rsa); err != nil {
	    return err
	}
	fd.isConnected = true
    } else {
	if err := fd.init(); err != nil {//最终会走到 fd.init()
	    return err
	}
    }
    return nil
}
func (fd *netFD) connect(ctx context.Context, la, ra syscall.Sockaddr) (ret error) {
    if err := fd.init(); err != nil { // 最终会call到 fd.init()
	return err
    }
</pre>
</div>
</li>
<li>net/fd_unix.go 然后看看netFD结构体的init(),就是上面的fd.init()<br  />
<div class="org-src-container">

<pre class="src src-go">// Network file descriptor.
type netFD struct {
    // locking/lifetime of sysfd + serialize access to Read and Write methods
    fdmu fdMutex

    // immutable until Close
    sysfd       int
    family      int
    sotype      int
    isConnected bool
    net         string
    laddr       Addr
    raddr       Addr

    // wait server
    pd pollDesc //这个结构体很重要
}
func (fd *netFD) init() error {
    //fd.pd 是个pollDesc类型,具体的pd.init()见下面
    if err := fd.pd.init(fd); err != nil {
	return err
    }
    return nil
}
</pre>
</div>
</li>

<li>net/fd_poll_runtime.go 注意找到文件<br  />
<div class="org-src-container">

<pre class="src src-go">// runtimeNano returns the current value of the runtime clock in nanoseconds.
func runtimeNano() int64

func runtime_pollServerInit()
func runtime_pollOpen(fd uintptr) (uintptr, int)
func runtime_pollClose(ctx uintptr)
func runtime_pollWait(ctx uintptr, mode int) int
func runtime_pollWaitCanceled(ctx uintptr, mode int) int
func runtime_pollReset(ctx uintptr, mode int) int
func runtime_pollSetDeadline(ctx uintptr, d int64, mode int)
func runtime_pollUnblock(ctx uintptr)

type pollDesc struct {
    runtimeCtx uintptr
}

var serverInit sync.Once

func (pd *pollDesc) init(fd *netFD) error {
    // 这里的代码开始进入真正的初始化，通过sync.Once来保证runtime_pollServerInit这个函数只会被调用一次
    //文件开头却只是声明了runtime_pollServerInit一个空函数
    serverInit.Do(runtime_pollServerInit)
     上面是epoll_create的初始化
      下面这句则是本fd的open过程

     //runtime_pollOpen的跟踪，直接看本文 runtime_pollOpen分支
    ctx, errno := runtime_pollOpen(uintptr(fd.sysfd))
    if errno != 0 {
	return syscall.Errno(errno)
    }
    pd.runtimeCtx = ctx
    return nil
}
</pre>
</div>
</li>
</ol>
</div>
</div>


<div id="outline-container-sec-1-3" class="outline-3">
<h3 id="sec-1-3">runtime_pollServerInit跟踪 这个过程会跟踪到epollcreate的调用</h3>
<div class="outline-text-3" id="text-1-3">
<p>
net/fd_poll_runtime.go 文件中声明的 runtime_pollServerInit是个空函数，导致似乎跟踪到此就结束了<br  />
然后似乎没非如此，用grep在整个代码搜索runtime_pollServerInit  会有以下结果<br  />
</p>

<blockquote>
<p>
./net/fd_poll_runtime.go:18:func runtime_pollServerInit()<br  />
./net/fd_poll_runtime.go:34:        serverInit.Do(runtime_pollServerInit)<br  />
./runtime/netpoll.go:80://go:linkname net_runtime_pollServerInit net.runtime_pollServerInit<br  />
./runtime/netpoll.go:81:func net_runtime_pollServerInit() {<br  />
</p>
</blockquote>
<p>
我们打开./runtime/netpoll.go找到80行左右有如下代码<br  />
</p>
<div class="org-src-container">

<pre class="src src-go">  //从这行注释来看 net.runtime_pollServerInit 似乎是有关联的，
  //怀疑 go compile时会对其进行相应的处理,
  //这里暂且就认为 net.runtime_pollServerInit() == runtime.net_runtime_pollServerInit()
//go:linkname net_runtime_pollServerInit net.runtime_pollServerInit
func net_runtime_pollServerInit() {
    netpollinit()
    atomic.Store(&amp;netpollInited, 1)
}
</pre>
</div>
<p>
runtime/netpoll_epoll.go<br  />
</p>
<div class="org-src-container">

<pre class="src src-go">  var (
      epfd int32 = -1 // epoll descriptor
  )

func netpollinit() {
    epfd = epollcreate1(_EPOLL_CLOEXEC)
    if epfd &gt;= 0 {
	return
    }
    epfd = epollcreate(1024) // 看到这里就看到了epollcreate的身影了
    if epfd &gt;= 0 {
	closeonexec(epfd)
	return
    }
    println("netpollinit: failed to create epoll descriptor", -epfd)
    throw("netpollinit: failed to create descriptor")
}
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2">epoll_ctrl的跟踪</h2>
<div class="outline-text-2" id="text-2">
<p>
我们再次回到上文中提到的一块代码pollDesc.init()的过程<br  />
</p>
<ol class="org-ol">
<li>net/fd_poll_runtime.go 注意找到文件<br  />
<div class="org-src-container">

<pre class="src src-go">// runtimeNano returns the current value of the runtime clock in nanoseconds.
func runtimeNano() int64

func runtime_pollServerInit()
func runtime_pollOpen(fd uintptr) (uintptr, int)
func runtime_pollClose(ctx uintptr)
func runtime_pollWait(ctx uintptr, mode int) int
func runtime_pollWaitCanceled(ctx uintptr, mode int) int
func runtime_pollReset(ctx uintptr, mode int) int
func runtime_pollSetDeadline(ctx uintptr, d int64, mode int)
func runtime_pollUnblock(ctx uintptr)

type pollDesc struct {
    runtimeCtx uintptr
}

var serverInit sync.Once

func (pd *pollDesc) init(fd *netFD) error {
    serverInit.Do(runtime_pollServerInit)
	上面是epoll_create的初始化
	下面这句则是本fd的open过程
	//runtime_pollOpen的跟踪，
    ctx, errno := runtime_pollOpen(uintptr(fd.sysfd)) //重点这一行
    if errno != 0 {
	return syscall.Errno(errno)
    }
    pd.runtimeCtx = ctx
    return nil
}
</pre>
</div>
</li>

<li>runtime/netpoll.go 相同的方式，我们找到了net_runtime_pollOpen这个函数<br  />
<div class="org-src-container">

<pre class="src src-goj">//go:linkname net_runtime_pollOpen net.runtime_pollOpen
func net_runtime_pollOpen(fd uintptr) (*pollDesc, int) {
    pd := pollcache.alloc()
    errno = netpollopen(fd, pd)
    return pd, int(errno)
}
</pre>
</div>
</li>
<li>runtime/netpoll_epoll.go<br  />
<div class="org-src-container">

<pre class="src src-go">func netpollopen(fd uintptr, pd *pollDesc) int32 {
    var ev epollevent
    ev.events = _EPOLLIN | _EPOLLOUT | _EPOLLRDHUP | _EPOLLET
    *(**pollDesc)(unsafe.Pointer(&amp;ev.data)) = pd
    //分析到这里，我们找到epollctl的身影
    //再往下分析就分析到各种操作系统使用汇编实现epollctl的过程了，epollctl到此结束
    return -epollctl(epfd, _EPOLL_CTL_ADD, int32(fd), &amp;ev)

}
</pre>
</div>
</li>
</ol>
</div>
</div>
<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3">epoll_wait 与golang 的异步IO</h2>
<div class="outline-text-2" id="text-3">
<p>
runtime/netpoll_epoll.go文件中 我们找到了 epollwait的身影<br  />
先不管哪些地方会调用到这，先分析下这个函数<br  />
文档中有这样一段描述<br  />
<a href="http://man7.org/linux/man-pages/man2/epoll_wait.2.html">http://man7.org/linux/man-pages/man2/epoll_wait.2.html</a><br  />
</p>
<blockquote>
<p>
 When successful, epoll_wait() returns the number of file descriptors<br  />
ready for the requested I/O, or zero if no file descriptor became<br  />
ready during the requested timeout milliseconds.  When an error<br  />
occurs, epoll_wait() returns -1 and errno is set appropriately.<br  />
</p>
</blockquote>
<div class="org-src-container">

<pre class="src src-go">    // polls for ready network connections
    // returns list of goroutines that become runnable
    func netpoll(block bool) *g {
	if epfd == -1 {
	    return nil
	}
	waitms := int32(-1) //-1 表示无限期的block
	if !block {
	    waitms = 0 //马上返回,即使没有任何事件发生
	}
	var events [128]epollevent
   我的理解的（不知道对不对）:
  下面这段代码 基本可以确定无论传入参数block 值为何 都在一值在epollwait这里等待
  直到收到内核相应的处理结果才会返回，差别仅仅是block在内核还是block 在这里
    retry:
	n := epollwait(epfd, &amp;events[0], int32(len(events)), waitms)   //
	if n &lt; 0 {
	    if n != -_EINTR {
		# EINTR  The call was interrupted by a signal handler before either (1)
		# any of the requested events occurred or (2) the timeout
		# expired; see signal(7).
		println("runtime: epollwait on fd", epfd, "failed with", -n)
		throw("epollwait failed")
	    }
	    goto retry
	}
	var gp guintptr
	for i := int32(0); i &lt; n; i++ {
	    ev := &amp;events[i]
	    if ev.events == 0 {
		continue
	    }
	    var mode int32
	    if ev.events&amp;(_EPOLLIN|_EPOLLRDHUP|_EPOLLHUP|_EPOLLERR) != 0 {
		mode += 'r'
	    }
	    if ev.events&amp;(_EPOLLOUT|_EPOLLHUP|_EPOLLERR) != 0 {
		mode += 'w'
	    }
	    if mode != 0 {
		pd := *(**pollDesc)(unsafe.Pointer(&amp;ev.data))

		netpollready(&amp;gp, pd, mode) //内核数据准备就继，可以进行IO了
	    }
	}
	if block &amp;&amp; gp == 0 {
	    goto retry
	}
	return gp.ptr()
    }
</pre>
</div>
<p>
再往下分析就是 goroutines的调度分析了，<br  />
在runtime.proc.go这个文件中可以看到netpoll的身影,goroutines的调度 暂时还没时间看， 先不乱贴代码了，留待以后分析<br  />
</p>
</div>
</div>

</div>
</div>
    <div>
      <div class="post-meta">
        <span title="post date" class="post-info">2017-08-01</span>
        <span title="last modification date" class="post-info">2017-08-02</span>
        <span title="tags" class="post-info"><a href="/tags/golang/">Golang</a></span>
        <span title="author" class="post-info">纪秀峰</span>
      </div>
      <section>
        <h1>Comments</h1>
        <div id="disqus_thread"></div>
        <script type="text/javascript">
          //var disqus_developer = 1;
          var disqus_identifier = "/blog/go_epoll.html";
          var disqus_url = "http://jixiuf.github.io/blog/go_epoll.html";
          var disqus_shortname = 'jixiuf';
          /* * * DON'T EDIT BELOW THIS LINE * * */
          (function() {
          var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
          dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
          (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
          })();
        </script>
        <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
        <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
        <div class="ds-thread"></div>
        <script type="text/javascript">
          var duoshuoQuery = {short_name:'jixiuf'};
          (function() {
          var ds = document.createElement('script');
          ds.type = 'text/javascript';ds.async = true;
          ds.src = 'http://static.duoshuo.com/embed.js';
          ds.charset = 'UTF-8';
          (document.getElementsByTagName('head')[0]
          || document.getElementsByTagName('body')[0]).appendChild(ds);
          })();
        </script>
      </section>
      <script src="http://code.jquery.com/jquery-latest.min.js"></script>
      <!-- <script src="https://cdnjs.cloudflare.com/ajax/libs/prettify/r298/prettify.js"></script> -->
      <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
      <script src="/media/js/main.js"></script>
      <div class="footer">
        <p>Generated by <a href="http://www.gnu.org/software/emacs/">Emacs</a> 26.x (<a href="http://orgmode.org">Org mode</a> 8.x)</p>
        <p>
          Copyright &copy; 2012 - <span id="footerYear"></span> <a href="mailto:jixiuf &lt;at&gt; qq &lt;dot&gt; com">纪秀峰</a>
          &nbsp;&nbsp;-&nbsp;&nbsp;
          Powered by <a href="https://github.com/kelvinh/org-page" target="_blank">org-page</a>
          <script type="text/javascript">document.getElementById("footerYear").innerHTML = (new Date()).getFullYear();</script>
        </p>
      </div>
    </div>

  </body>
</html>
